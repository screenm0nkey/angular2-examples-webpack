<h4>Dependency Injection</h4>


<a target="_blank" href="http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html">
Dependency Injection
</a>

<inject-component></inject-component>
<br>
<di-sample-app></di-sample-app>
<br>
<di-sample-app2></di-sample-app2>
<br>
<pre>
Every component comes with its own injector.
<a target="_blank" href="http://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html">BYPASSING PROVIDERS IN ANGULAR 2</a>
If we provide services in a module they will be globally available as all modules use the root injector.
<a href="http://stackoverflow.com/questions/39828246/angular-2-how-to-isolate-service-provider-in-a-feature-module" target="_blank">Isolate service</a>
This is not the case with Lazy loaded modules. Essentially lazy loading could trigger
certain bugs related to services overriding each other in the global context
and that are hard to reproduce due to accidental overwrites of injectables ?
in order to avoid this what Angular 2 will do when lazy loading a module is that
it will create a child dependency injection context. This Home DI context will
contain the LessonsService, but this service will not be visible to the rest of the application.



When a module is loaded at application launch, its @NgModule.providers have application-wide scope.
They are available for injection throughout the application. Load the module lazily if you can.
Angular gives a lazy-loaded module its own child injector. The module's providers are visible only
within the component tree created with this injector. If you must load the module eagerly, when the
application starts, provide the service in a component instead.

The DI in Angular 2 basically consists of three things:
<strong>Injector</strong> - The injector object that exposes APIs to us to create instances of dependencies.
<strong>Provider</strong> - A provider is like a recipe that tells the injector how
to create an instance of a dependency. A provider takes a token and maps
that to a factory function that creates an object.
<strong>Dependency</strong> - A dependency is the type of which an object should be created.

We get a service from a dependency injector by giving it a token.

<strong>constructor(logger: LoggerService) &#123;
logger.logInfo('Creating HeroBiosComponent');
&#125;</strong>

In the case above Angular asks the injector for the service associated
with the token called LoggerService and and assigns the returned value
to the logger parameter.

A provider is a recipe for delivering a service associated with a
token (see below for what a token is).

If the injector doesn't have a provider for the requested token, it delegates
the request to its parent injector, where the process repeats until there are
no more injectors

A new injector has no providers. Each component has it's own injector or child-injector

The simple class provider is the most typical by far.

<strong>&#123; provide: LoggerService, useClass: DateLoggerService &#125;</strong>
The “LoggerService” is the token, the “DateLoggerService” is the definition object

The provide object literal above takes a token and a definition object.
The token is usually a class but it doesn't have to be.

Set the useValue property to a fixed value that the provider can return as the dependency object.

Use this technique to provide runtime configuration constants such as web-site
base addresses and feature flags. We often use a value provider in a unit test
to replace a production service with a fake or mock.
</pre>
