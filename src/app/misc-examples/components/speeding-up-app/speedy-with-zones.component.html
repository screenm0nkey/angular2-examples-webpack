<div>
  <p class="file">misc-examples/components/speeding-up-app/speedy-with-zones.component.ts</p>
  <h4>Using Zones to speed up an Application</h4>
  <p><a href="https://blog.thoughtram.io/angular/2017/02/21/using-zones-in-angular-for-better-performance.html"
        target="_blank">
    Using Zones for better performance
  </a></p>

  <code>this.zone.runOutsideAngular()</code>

  <p>
    So the reason it's faster outside of the NgZone is because when you add a handler to an event like "mousemove" it is
    actually using
    Zone.onmousemove, which triggers the change detection when the event occurs. <strong>Binding the event handler
    outside
    of Zone stops the change detection being triggered.</strong> If you look at the console you will only see the change
    detection
    happening a few times when it's outside.
  </p>

  <p class="strong">
    One interesting point is that the change detection for a component won't be invoked unless it is using
    any of the monkey-patched events. i.e. if there if there are no event handlers used like
    <code>(mousedown)="mouseDown($event)"</code>
    then the <code>ngDoCheck()</code> will not be called.
  </p>

  <p>
    <span style="font-weight: bold">Monkey-patched Hooks</span><br>
    For example, when we call setTimeout() we actually call Zone.setTimeout(), which in turn creates a new zone using
    zone.fork() in which the given handler is executed. And that’s why our hooks are executed as well, because the
    forked zone in which the handler will be executed, simply inherits from the parent zone.
  </p>

  <p>
    <strong>Using Zones is a great way to escape Angular’s change detection, without detaching change detectors and making
    the application code too complex.</strong> In fact, it turns out that Zones APIs are super easy to use, especially NgZone’s
    APIs to run code outside or inside Angular. Based on the numbers, we can even say that the NgZone example is
    about as fast as the fastest solution above it.
  </p>
</div>
