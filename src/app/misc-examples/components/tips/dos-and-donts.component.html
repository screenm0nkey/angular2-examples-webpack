<h4>Do's and Don'ts</h4>
1) <dlink [id]="82"></dlink><br>
2) <dlink [id]="94"></dlink><br>
3) <dlink [id]="95"></dlink><br>
4) <dlink [id]="96"></dlink><br>
<hr>
<p>
  <strong>In your application, 80–90% of your components should be presentational. A
    presentational component should take Inputs and emit Outputs, nothing else</strong>.
  Yes, it may have its little inner state: that’s not a problem. It’s perfectly
  fine for a TabsComponent, for example, to accept an index from outside but
  keeping the currentIndex in a property. As long as it has an indexChange
  output who tells the parent about the change (bonus: having the
  index/indexChange pair will let you use the 2-way-binding syntax [(index)] in
  Angular!). Does that make the component less-stateless? Yes, but it’s still
  manageable from the outside and it can also work on its own. Win win.
</p>

<p>
  <strong>What’s a container?</strong> It’s the component which hosts all the presentational
  components of that “view”, or route: it’s the only one which should use
  services to get/update data, which should use the Redux store, which should
  dispatch actions, and which should pass its inner state (or slices of that) to
  the child components. All the child components are presentational and should
  not even know where the data has come from or what the consequences of their
  Outputs will be. If tomorrow you decide to include a state-management library
  or to get rid of it, your presentational components won’t break.
</p>


<ul>
  <li class="strong">Do</li>
  <li>Use ChangeDetectionStrategy OnPush</li>
  <li>Container Componentns delegate responsibilities to a service.</li>
  <li>Containers can be split if they are too big</li>
  <li>Use Directives as a way to incapsulate behaviors and reuse them</li>
  <li>Use Content Projection</li>
  <li>Provide Default Value for Optional Inputs (see link No.3)</li>
  <li>Use *ngIf rather than binding to the [hidden] property (see below)</li>

</ul>
<hr>
<ul>
  <li class="strong">Donts</li>
  <li>Huge forms : Use ControlValueAccessor to create sub-forms.(see link 4)</li>
  <li>Modify the Input data directly</li>
  <li>Use models from other modules</li>
  <li>Your containers shouldn’t do have complicated logic. Use services</li>
  <li>Relying on ViewChild for communication. Avoid calling methods on child components to change the state of the
    component (3)(2)</li>
  <li>Convert subscribables into promises (2)</li>
  <li>Avoid calling components methods or getters from the component template as it can slow it down. (2)</li>

</ul>