<div class='comps'>

  <section>
    <p class="file">/misc-examples/components/dependecy-injection/dependency.html</p>
    <h4>Dependency Injection</h4>
    <p class="links">

      <a href="http://angularfirst.com/the-ngmodule-forroot-convention/" target="_blank">
        The NgModule <code>forRoot()</code> Convention
      </a>

      <a href="https://blog.angular-university.io/angular2-ngmodule/" target="_blank">
        Search this article for <code>forRoot()</code>
      </a>

      <a target="_blank" href="http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html"
         target="_blank">
        Dependency Injection
      </a>
      <a href="http://blog.thoughtram.io/angular/2016/05/23/opaque-tokens-in-angular-2.html" target="_blank">
        InjectionToken (was OpaqueToken)
      </a>
      <a href="https://blog.thoughtram.io/angular2/2015/11/23/multi-providers-in-angular-2.html" target="_blank">
        Multi Providers
      </a>
      <a target="_blank" href="http://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html"
         class="block" target="_blank">
        BYPASSINGPROVIDERS IN ANGULAR 2
      </a>
      <a
        href="http://stackoverflow.com/questions/39828246/angular-2-how-to-isolate-service-provider-in-a-feature-module"
        target="_blank" class="block" target="_blank">
        Angular 2 how to isolate service provider in a feature module
      </a>
    </p>

    <section class="well">
      <a href="https://blog.ninja-squad.com/2018/05/04/what-is-new-angular-6/" target="_blank">New to Ng6</a>
      <p>There is now a new, recommended, way to register a provider, directly inside the <code>@Injectable()</code>
        decorator, using
        the
        new providedIn attribute. It accepts 'root' as a value or any module of your application. When you use 'root',
        your
        injectable will be registered as a singleton in the application, and you don’t need to add it to the providers
        of
        the root module. Similarly, if you use <code>providedIn: UsersModule</code>, the injectable is registered as a
        provider of the
        UsersModule without adding it to the providers of the module.</p>

      <code>
        @Injectable(&#123;
        providedIn: 'root'
        &#125;)
      </code>


    </section>
    <ul>
      <li>Every component comes with its own injector</li>

      <li>Providers are flattened, meaning that, if there are multiple providers with the same token, the
        last one wins. Use <code>InjectionToken</code> to avoid overwriting provider.
      </li>

      <li>When using a string token we HAVE to use <code>@Inject</code>, i.e. <code>@Inject('whateverToken') public
        some3</code></li>

      <li>
        multi providers <code>multi: true</code> basically extend the thing that is being injected for a particular
        token.
        Angular uses this mechanism to provide pluggable hooks i.e extending <code>NG_VALIDATORS,
        HTTP_INTERCEPTORS</code>
      </li>

      <li>If we provide services in a module they will be globally available as all modules use the root
        injector. This is NOT the case with Lazy loaded modules, who get their own injector.
        See <a routerLink="../modules" routerLinkActive="active">Modules</a> for more info.
        This can be avoided and a singleton can be created if you <code>forRoot()</code>
      </li>
      <li>
        When a module is loaded at application launch, its providers (services) have application-wide scope. They are
        available for injection throughout the application, which is why you should try load the module lazily if you
        can.
        <strong>Angular gives a lazy-loaded module its own child injector. The module's providers are visible only
          within
          the component tree created with this injector. If you must load the module eagerly, when the application
          starts,
          provide the service in a component instead i.e. <code>@Component(&#123;providers : [...&#125;)</code>
        </strong>
        <a
          href="https://stackoverflow.com/questions/39828246/angular-2-how-to-isolate-service-provider-in-a-feature-module"
          target="_blank">Taken from here</a>
      </li>

      <li>If the injector doesn't have a provider for the requested token, it delegates
        the request to its parent injector, where the process repeats until there are
        no more injectors.
      </li>

      <li>A new injector has no providers. Each component has it's own injector or child-injector</li>
    </ul>

    <div class="well">
      <h6>Create Multiple Angular Service Instances</h6>
      <a href="https://egghead.io/lessons/angular-create-multiple-angular-service-instances" target="_blank">Egghead
        Lesson</a>
      <p>An Angular service registered on the NgModule is globally visible on the entire application.
        Moreover it is a singleton instance, so every component that requires it via its constructor, will get the same
        instance. However this is not always the desired behavior.
        Rather you may like to get a fresh instance of a given service every time a component requests it.</p>
      <p>To Accomplish that, provide the service directly in the component <code>providers: [PersonService]</code></p>
    </div>

    <section class="well">
      <h6>Create a true singleton</h6>
      <p>Multiple versions of the same injectable are possible, as it the case with 'MrTestyServiceTwo'
        Because the service is injected via a lazy-loaded module it creates a new instance of the injectable,
        even though it's already been injected in the /ngrx-queue.component.ts
        <i>See the console.log 'Created an instance of MrTestyServiceTwo'</i></p>
      <p>
        1) there is only a single instance of MrTestyServiceOne being created but multiple MrTestyServiceTwo.
        This is due to the way they are declared in the module src/app/shared/shared.module.ts
        MrTestyServiceOne is configured using <code>forRoot</code>, which will only ever produce a single instance of
        the
        service.
      </p>
    </section>

    <section class="well">
      <h6>Define an Aliased Class Provider with useExisting.</h6>
      <div class="links">
        <a href="https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html" target="_blank">bypassing-providers-in-angular-2</a>
        <a href="https://egghead.io/lessons/angular-define-an-aliased-class-provider-in-angular" target="_blank">Alias
          classes</a>
      </div>
      <code>providers: [NewLoggerService,&#123; provide: LoggerService, useExisting: NewLoggerService &#125;]</code>
      <p>useExisting is a bit different than the other provider strategies. It’s the only strategy that doesn’t actually
        create an instance, but instead, it points to another token which in turn will create the instance.</p>
    </section>

    <section class="well">
      Take a look at the RubbishService. It is defined in the DependencyModule but it's used in both the <a
      routerLink="../tricks" routerLinkActive="active">Tricks</a> and
      <a routerLink="../tips" routerLinkActive="active">Tips</a>Components but it is not declared in either of their
      modules.
    </section>

    <p>
      Essentially lazy loading could trigger
      certain bugs related to services overriding each other in the global context
      that are hard to reproduce due to accidental overwrites of injectables.
      In order to avoid this this, angular will create a child dependency injection context.
      This context will contain the service, but <strong>this service will not be visible to the rest of the
      application.</strong>
    </p>

    <section class="well">
      <h6>The DI in Angular 2 basically consists of three things:</h6>
      <ul>
        <li>
          <span class="red">Injector</span> - The injector object that exposes APIs to allow us to create instances of
          dependencies
        </li>
        <li><span class="red">Token</span> - -A token is the key in the key/value pair of a provider.
          All Providers are flattened, meaning that, if there are multiple providers with the same token, the
          last one wins. Use <code>InjectionToken</code> to void this
        </li>
        <li><span class="red">Provider</span> - A provider is a recipe for delivering a service associated with a
          token. It tells the injector how to create an
          instance of a dependency. A provider takes a token and maps that to a factory function that creates an object.
        <li>
          <span class="red">Dependency</span> - A dependency is the type of which an object should be created.
        </li>
      </ul>

    </section>

    <p class="code-example">We get a service from a dependency injector by giving it a token. <br>In the example below
      Angular asks the
      injector for
      the service associated
      with the token called "LoggerService" and assigns the returned value
      to the loggerFactory parameter.</p>

    <code>constructor(loggerFactory: LoggerService) &#123;
      loggerFactory.logInfo('Creating HeroBiosComponent');
      &#125;</code>


    <p class="code-example">The simple "class" Provider is the most typical by far. <br> The example below takes a token
      and a
      definition object. The token is usually a class but it doesn't have to be.</p>
    <code>&#123; provide: LoggerService, useClass: DateLoggerService &#125;</code>

    <p>The “LoggerService” is the token, the “DateLoggerService” is the Definition Object or Factory</p>


    <p><strong>Set the "useValue" property to a fixed value that the provider can return as the dependency
      object.</strong></p>

    <code> providers: [&#123;provide: 'URL', useValue: 'https://swapi.co/api'&#125;]</code>

    <p>Use this technique to provide runtime configuration constants such as web-site
      base addresses and feature flags. We often use a value provider in a unit test
      to replace a production service with a fake or mock.</p>

    <section class="well">
      <h6>Element Injectors</h6>
      <p>Angular resolves dependencies in 3 stages starting with the hierarchy of element injectors and moving up to
        component injectors and then module injectors.</p>

      <p>The last two stages of the resolution process that goes upwards through module and component injectors.
        Angular creates a hierarchy of module injectors when you lazy load a module. The hierarchy of component
        injectors
        is created by nesting components in templates. Internally, <strong>component injectors are also referred to as
          View
          Injectors</strong></p>
      <p>A hierarchy of element injectors, on the other hand, is a lesser-known feature of Angular’s DI system mostly
        because it’s not really documented anywhere. But exactly this kind of injectors is the first stage of the DI
        resolution process. And these injectors make up a hierarchy that is used to resolve dependencies decorated with
        the <code>@Host</code> decorator. </p>
      <a
        href="https://blog.angularindepth.com/a-curios-case-of-the-host-decorator-and-element-injectors-in-angular-582562abcf0a"
        target="_blank">
        Indepth guide to @Host
      </a>
    </section>
  </section>

  <app-person-parent></app-person-parent>

  <inject-component></inject-component>

  <inject-parent-component></inject-parent-component>

  <resolve-create-service></resolve-create-service>

  <resolve-create-factory></resolve-create-factory>
</div>




