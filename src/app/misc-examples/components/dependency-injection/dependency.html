<div class='comps'>

  <section>
    <p class="file">misc-examples/components/dependency-injection/dependency.component.ts</p>
    <h4>Dependency Injection</h4>

    <p class="links">
      <ext-link *ngFor="let link of links" [linkObj]="link"></ext-link>
    </p>

    <section class="well">
      <h6>providedIn</h6>
      <a href="https://blog.ninja-squad.com/2018/05/04/what-is-new-angular-6/" target="_blank">New to Ng6</a>
      <p>There is now a new, recommended, way to register a provider, directly inside the <code>@Injectable()</code>
        decorator, using the new <code>providedIn</code> attribute. It accepts 'root' as a value or any module of your
        application. When you use 'root',
        your injectable will be registered as a singleton in the application, and you don’t need to add it to the
        providers of the root module. Similarly, if you use <code>providedIn: UsersModule</code>, the injectable is
        registered as
        a provider of the UsersModule without adding it to the providers of the module.</p>

      <code>
        @Injectable(&#123;
        providedIn: 'root'
        &#125;)
      </code>
    </section>


    <section class="well">
      <p>Using <code>providers: []</code> property in a @NgModule can lead to four different scenarios based on specific
        circumstances…</p>

      <h6>Eager @NgModule</h6>
      <p>In this case, service will be registered as a global singleton. Service will be provided as a singleton even if
        it is included in the providers:[] of multiple eager modules. Only one instance will be created by the injector
        and this is because they will all end up registered with the root level injector.</p>

      <h6>Lazy @NgModule</h6>
      <p>Instance of the service provided in the lazy module will be created on the child injector (of the lazy module)
        when initialized later during the application run-time. Injecting such a service into the eager part would lead
        to No provider for MyService! error.</p>

      <h6>Declarables — @Component or @Directive</h6>
      <p>Component providers are made available to the component and all its view AND content child components
        (i.e. components in its template but also projected components rendered by <code>ng-content</code>).</p>

      <h6>View providers</h6>
      <p>They are only made available for the component and its view child components. They are declared by the
        viewProviders option in the component decorator.</p>
    </section>

    <h6>Lazy loading & The providedIn: ‘root’ solution</h6>
    <p>What would happen if we used providedIn: 'root' to implement service which we want to use in lazy loaded
      module?</p>

    <p>Technically, <strong>the 'root' stands for AppModule</strong> but Angular is smart enough to bundle service in
      the lazy loaded
      bundle if it is only injected in the lazy components / services. But there is a catch.
      If we later additionally inject service which is meant to belong to lazy module in any eager part of the
      application it will be then automatically bundled in the main bundle. To summarize…</p>

    <p>If the service is only injected in the lazy part, it will be bundled in lazy bundle
      If the service is injected in the eager part (while still possibly being injected in the lazy part), it will be
      bundled in the eager main bundle
      The problem with this behavior is that it can get quite unpredictable in the larger applications with tons of
      modules and hundreds of services.</p>


    <section class="well">
      <h6>Summarization for providedIn</h6>
      <ul>
        <li>Use providedIn: 'root' for services which should be available in whole application as singletons</li>
        <li>Use providedIn: LazyServiceModule to prevent service injection in the eagerly imported part of the
          application
        </li>
        <li>To prevent usage of a services outside of the desired module, use LazyServiceModule which will be imported
          by LazyModule to prevent circular dependency warning. LazyModule will then be lazy loaded using Angular Router
          for some route in a standard fashion <a href="https://medium.com/@tomastrajan/total-guide-to-angular-6-dependency-injection-providedin-vs-providers-85b7a347b59f" target="_blank">See how to</a>.
        </li>
        <li class="strong">Use providers: [] inside of @Component or @Directive to scope service only for the particular
          component sub-tree which will also lead to creation of multiple service instances (one service instance per
          one component usage)
        </li>
        <li>Always try to scope your services conservatively to prevent dependency creep and resulting tangled hell</li>
      </ul>
    </section>


    <section class="well">
      <ul>
        <li>Every component comes with its own injector</li>

        <li>Providers are flattened, meaning that, if there are multiple providers with the same token, the
          last one wins. Use <code>InjectionToken</code> to avoid overwriting provider.
        </li>

        <li>When using a string token we HAVE to use <code>@Inject</code>, i.e. <code>@Inject('whateverToken') public
          some3</code></li>

        <li>
          multi providers <code>multi: true</code> basically extend the thing that is being injected for a particular
          token.
          Angular uses this mechanism to provide pluggable hooks i.e extending <code>NG_VALIDATORS,
          HTTP_INTERCEPTORS</code>
        </li>

        <li>If we provide services in a module they will be globally available as all modules use the root
          injector. This is NOT the case with Lazy loaded modules, who get their own injector.
          See <a routerLink="../modules" routerLinkActive="active">Modules</a> for more info.
          This can be avoided and a singleton can be created if you <code>forRoot()</code>
        </li>
        <li>
          When a module is loaded at application launch, its providers (services) have application-wide scope. They are
          available for injection throughout the application, which is why you should try load the module lazily if you
          can.
          <strong>Angular gives a lazy-loaded module its own child injector. The module's providers are visible only
            within
            the component tree created with this injector. If you must load the module eagerly, when the application
            starts,
            provide the service in a component instead i.e. <code>@Component(&#123;providers : [...&#125;)</code>
          </strong>
          <a
            href="https://stackoverflow.com/questions/39828246/angular-2-how-to-isolate-service-provider-in-a-feature-module"
            target="_blank">Taken from here</a>
        </li>

        <li>If the injector doesn't have a provider for the requested token, it delegates
          the request to its parent injector, where the process repeats until there are
          no more injectors.
        </li>

        <li>A new injector has no providers. Each component has it's own injector or child-injector</li>
      </ul>
    </section>

    <div class="well">
      <h6>Create Multiple Angular Service Instances</h6>
      <a href="https://egghead.io/lessons/angular-create-multiple-angular-service-instances" target="_blank">Egghead
        Lesson</a>
      <p>An Angular service registered on the NgModule is globally visible on the entire application.
        Moreover it is a singleton instance, so every component that requires it via its constructor, will get the same
        instance. However this is not always the desired behavior.
        Rather you may like to get a fresh instance of a given service every time a component requests it.</p>
      <p>To Accomplish that, provide the service directly in the component <code>providers: [PersonService]</code></p>
    </div>

    <section class="well">
      <h6>Create a true singleton</h6>
      <p>Multiple versions of the same injectable are possible, as it the case with 'MrTestyServiceTwo'
        Because the service is injected via a lazy-loaded module it creates a new instance of the injectable,
        even though it's already been injected in the /ngrx-queue.component.ts
        <i>See the console.log 'Created an instance of MrTestyServiceTwo'</i></p>
      <p>
        1) there is only a single instance of MrTestyServiceOne being created but multiple MrTestyServiceTwo.
        This is due to the way they are declared in the module src/app/shared/shared.module.ts
        MrTestyServiceOne is configured using <code>forRoot</code>, which will only ever produce a single instance of
        the
        service.
      </p>
    </section>

    <section class="well">
      <h6>Define an Aliased Class Provider with <code>useExisting</code></h6>
      <div class="links">
        <a href="https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html" target="_blank">bypassing-providers-in-angular-2</a>
        <a href="https://egghead.io/lessons/angular-define-an-aliased-class-provider-in-angular" target="_blank">Alias
          classes</a>
      </div>
      <code>providers: [NewLoggerService,&#123; provide: LoggerService, useExisting: NewLoggerService &#125;]</code>
      <p><code>useExisting</code> is a bit different than the other provider strategies. It’s the only strategy that
        doesn’t actually
        create an instance, but instead, it points to another token which in turn will create the instance.</p>
    </section>

    <section class="well">
      Take a look at the RubbishService. It is defined in the DependencyModule but it's used in both the <a
      routerLink="../tricks" routerLinkActive="active">Tricks</a> and
      <a routerLink="../tips" routerLinkActive="active">Tips</a>Components but it is not declared in either of their
      modules.
    </section>

    <p>
      Essentially lazy loading could trigger
      certain bugs related to services overriding each other in the global context
      that are hard to reproduce due to accidental overwrites of injectables.
      In order to avoid this this, angular will create a child dependency injection context.
      This context will contain the service, but <strong>this service will not be visible to the rest of the
      application.</strong>
    </p>

    <section class="well">
      <h6>The DI in Angular 2 basically consists of three things:</h6>
      <ul>
        <li>
          <span class="red">Injector</span> - The injector object that exposes APIs to allow us to create instances of
          dependencies
        </li>
        <li><span class="red">Token</span> - -A token is the key in the key/value pair of a provider.
          All Providers are flattened, meaning that, if there are multiple providers with the same token, the
          last one wins. Use <code>InjectionToken</code> to void this
        </li>
        <li><span class="red">Provider</span> - A provider is a recipe for delivering a service associated with a
          token. It tells the injector how to create an
          instance of a dependency. A provider takes a token and maps that to a factory function that creates an object.
        <li>
          <span class="red">Dependency</span> - A dependency is the type of which an object should be created.
        </li>
      </ul>

    </section>

    <p class="code-example">We get a service from a dependency injector by giving it a token. <br>In the example below
      Angular asks the
      injector for
      the service associated
      with the token called "LoggerService" and assigns the returned value
      to the loggerFactory parameter.</p>

    <code>constructor(loggerFactory: LoggerService) &#123;
      loggerFactory.logInfo('Creating HeroBiosComponent');
      &#125;</code>


    <p class="code-example">The simple "class" Provider is the most typical by far. <br> The example below takes a token
      and a
      definition object. The token is usually a class but it doesn't have to be.</p>
    <code>&#123; provide: LoggerService, useClass: DateLoggerService &#125;</code>

    <p>The “LoggerService” is the token, the “DateLoggerService” is the Definition Object or Factory</p>


    <p><strong>Set the "useValue" property to a fixed value that the provider can return as the dependency
      object.</strong></p>

    <code> providers: [&#123;provide: 'URL', useValue: 'https://swapi.co/api'&#125;]</code>

    <p>Use this technique to provide runtime configuration constants such as web-site
      base addresses and feature flags. We often use a value provider in a unit test
      to replace a production service with a fake or mock.</p>

    <section class="well">
      <h6>Element Injectors</h6>
      <p>Angular resolves dependencies in 3 stages starting with the hierarchy of element injectors and moving up to
        component injectors and then module injectors.</p>

      <p>The last two stages of the resolution process that goes upwards through module and component injectors.
        Angular creates a hierarchy of module injectors when you lazy load a module. The hierarchy of component
        injectors
        is created by nesting components in templates. Internally, <strong>component injectors are also referred to as
          View
          Injectors</strong></p>
      <p>A hierarchy of element injectors, on the other hand, is a lesser-known feature of Angular’s DI system mostly
        because it’s not really documented anywhere. But exactly this kind of injectors is the first stage of the DI
        resolution process. And these injectors make up a hierarchy that is used to resolve dependencies decorated with
        the <code>@Host</code> decorator. </p>
      <a
        href="https://blog.angularindepth.com/a-curios-case-of-the-host-decorator-and-element-injectors-in-angular-582562abcf0a"
        target="_blank">
        Indepth guide to @Host
      </a>
    </section>
  </section>

  <app-person-parent></app-person-parent>

  <inject-component></inject-component>

  <inject-parent-component></inject-parent-component>

  <resolve-create-service></resolve-create-service>

  <resolve-create-factory></resolve-create-factory>
</div>




